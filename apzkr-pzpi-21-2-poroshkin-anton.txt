Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для управління кліматом у готельній мережі з можливістю синхронізації персональних профілів

Студент гр. ПЗПІ-21-2	__________________ Порошкін А.С.
(підпис)
Керівник роботи	__________________ доц. Лещинський В.О.
(підпис)
	Роботу захищено «__»_________2024 р.
з оцінкою _________________________
Комісія:	__________________  доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)

Харків 
2024 р.
 
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			            6				____        
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Порошкіну Антону Сергійовичу
1.	Тема роботи: «Програмна система для управління кліматом у готельній мережі з можливістю синхронізації персональних профілів»	
2.	Термін узгодження завдання курсової роботи «26» лютого 2024 р.
3.	Термін здачі студентом закінченої роботи «31» травня 2024 р.
4.	Вихідні дані до проекту (роботи):  В програмній системі передбачити: управління готельною мережею, управління кліматичними профілями, синхронізацію персональних профілів клієнтів, статистику за кліматичними пристроями та їх виробниками. Використовувати ОС Windows 11, СКБД PostgreSQL, середовище розробки Visual Studio Code	
5.	Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз та концептуальне моделювання предметної області, проєктування програмної системи, розробка серверної частини системи, розробка програмного забезпечення для вбудованих системи, розробка клієнтського веб-застосунку, розробка мобільного застосунку, висновки, перелік посилань, додатки	
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) UML діаграма розгортання системи, UML діаграма прецедентів для адміністрації готельної мережі, UML діаграма прецедентів для клієнта готельної мережі, ER-діаграма даних для серверної частини застосунку, UML діаграма пакетів для серверної частини застосунку, UML діаграма прецедентів для IoT-пристрою, UML діаграма взаємодії IoT-пристрою з серверною частиною системи, UML діаграма пакетів програмного забезпечення для IoT-пристрою, UML діаграма діяльності для IoT-пристрою, UML діаграма компонент для клієнтського веб-застосунку, UML діаграма компонент для клієнтського веб-застосунку, UML діаграма діяльності для клієнтського веб-застосунку, UML діаграма компонент для мобільного застосунку, UML діаграма пакетів для мобільного застосунку, ER-модель даних мобільної платформи	
 
КАЛЕНДАРНИЙ ПЛАН


Номер	Назва етапів курсової роботи	Строк виконання етапів роботи	Примітки
1	Функціональна специфікація
програмного проекту	31.03.2024	Виконано
2	Проектування програмного
проекту	30.04.2024	Виконано
3	Кодування програмного проекту	20.05.2024	Виконано
4	Оформлення пояснювальної
записки	31.05.2024	Виконано
5	Захист курсової роботи	10.06.2024	Виконано

Дата видачі завдання «26» лютого 2024 р.
Керівник	__________________ доц. Лещинський В.О.
(підпис)

Завдання прийняв до виконання
ст. гр. ПЗПІ-21-2	__________________              Порошкін А.С.
(підпис)
	


 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 82 с., 15 рис., 5 додатків, 5 джерел.
ГОТЕЛЬНА МЕРЕЖА, УПРАВЛІННЯ КЛІМАТОМ, СИНХРОНІЗАЦІЯ, АВТОМАТИЗАЦІЯ.
Метою курсового проекту є створення програмної системи для управління кліматом у готельній мережі з можливістю синхронізації персональних профілів, що включає в себе створення серверної частини системи, розробку програмного забезпечення для пристрою інтернету речей (IoT), розробку браузерного та мобільного клієнтів, які нададуть змогу користувачам системи ефективного взаємодіяти з нею через зручний та зрозумілий користувацький інтерфейс.
Для розробки серверної частини системи було обрано фреймворк NestJS, Для зберігання даних було обрано СУБД PostgreSQL. Для розробки браузерного застосунку було обрано бібліотеку React. Для спрощення асинхронної взаємодії із сервером та синхронізації стану серверного і браузерного застосунків було обрано стейт-менеджер MobX. Для розробки мобільного застосунку було обрано фреймворк Jetpack Compose для мови програмування Kotlin.
 
ЗМІСТ


Вступ	8
1 Аналіз та концептуальне моделювання предметної області	9
1.1 Бізнес-вимоги	9
1.1.1 Передумови	9
1.1.2 Бізнес-можливості	10
1.1.3 Бізнес-цілі та критерії успіху	11
1.1.4 Потреби клієнтів та ринку	12
1.1.5 Бізнес-ризики	13
1.2 Концепція рішення	15
1.2.1 Окреслення концепції	15
1.2.2 Головна функціональність	16
1.2.3 Припущення та залежності	17
1.3 Рамки та обмеження	18
1.3.1 Рамки первинного випуску	18
1.3.2 Рамки наступних випусків	19
1.3.3 Обмеження та винятки	19
1.4 Бізнес-контекст	20
1.4.1 Профілі зацікавлених сторін	20
1.4.2 Пріоритети проєкту	21
1.4.3 Робоче середовище	22
2 Проєктування програмної системи	24
2.1 Опис архітектури системи	24
2.2 Побудова діаграми розгортання	24
3 Розробка серверної частини системи	26
3.1 Опис архітектури серверної частини системи 	26
3.2 Побудова діаграми прецедентів для серверної частини системи	27
3.3 Побудова ER-діаграми для серверної частини системи	28
3.4 Специфікація REST	30
3.4 Побудова діаграми пакетів	32
4 Розробка програмного забезпечення для вбудованих систем	33
4.1 Концептуальне моделювання системи	33
4.2 Опис роботи застосунку для вбудованих систем	34
4.2.1 Опис архітектурних рішень проєкту	34
4.2.2 Опис використаних технологій	34
4.2.3 Опис результатів розробки ПЗ для вбудованих систем	35
4.2.4 Опис результатів тестування ПЗ для вбудованих систем 	36
5 Розробка клієнтського веб-застосунку	37
5.1 Концептуальне моделювання системи	37
5.2 Опис розробки клієнтського веб-застосунку	37
5.2.1 Обґрунтування архітектурних рішень проєкту	37
5.2.2 Опис використаних технологій	38
5.2.3 Опис результатів розробки клієнтського веб-застосунку	39
5.2.4 Опис результатів тестування клієнтського веб-застосунку	41
6 Розробка мобільного застосунку	42
6.1 Концептуальне моделювання системи	42
6.2 Опис розробки мобільного застосунку	42
6.2.1 Обґрунтування архітектурних рішень проєкту	42
6.2.2 Опис використаних технологій	43
6.2.3 Опис результатів розробки мобільного застосунку	44
6.2.4 Опис результатів тестування мобільного застосунку	45
Висновки	46
Перелік джерел посилання	48
Додаток А Розроблені діаграми	49
Додаток Б Фрагменти коду серверної частини системи	64
Додаток В Фрагменти коду ПЗ для вбудованих систем	70
Додаток Г Фрагменти коду клієнтського веб-застосунку	74
Додаток Д Фрагменти коду мобільного застосунку	79 
ВСТУП


Сучасний готельний бізнес стикається з викликом створення персоналізованого досвіду для своїх гостей. Одним із ключових аспектів цього досвіду є можливість налаштування та контролю клімату в номері.
Відповідно, є попит на розробку програмних систем, які могли б допомогти автоматизувати управління кліматом у готельній мережі. Адміністрація готельних мереж стикається з низкою проблем, серед яких складність ведення обліку про готелі мережі, готельні номери, пристрої для управління кліматом, встановлені у цих номерах, та клієнтів, які проживають у готелях. Також складним завданням є планування технічного обслуговування пристроїв для управління кліматом та аналіз інформації про їх стан, оскільки без впровадження необхідних програмних систем відсутнє централізоване джерело інформації, з якого можна було б отримати дані про стан кліматичних пристроїв.
Щодо клієнтів готельних мереж, то вони з низкою проблем, серед яких необхідність керувати декількома пристроями (кондиціонери, термостати, зволожувачі) з різних інтерфейсів, складність створення та автоматизації сценаріїв роботи, що враховують індивідуальні потреби користувачів, необхідність постійно знову налаштовувати клімат у номері при подорожах через відсутність можливості синхронізації уподобань користувачів між різними закладами однієї готельної мережі.
Отже, метою курсового проєкту є створення програмної системи для управління кліматом у готельній мережі з можливістю синхронізації персональних профілів, що включає в себе створення серверної частини системи, розробку програмного забезпечення для пристрою інтернету речей (IoT), розробку браузерного та мобільного клієнтів, яка змогла б вирішити вищеперелічені проблеми адміністрації готельних  мереж та їх- клієнтів.
 
1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ
ОБЛАСТІ
1.1 Бізнес-вимоги
1.1.1 Передумови


Сучасний готельний бізнес стикається з викликом створення персоналізованого досвіду для своїх гостей. Одним із ключових аспектів цього досвіду є можливість налаштування та контролю клімату в номері.
Існуючі системи управління кліматом, як правило, фрагментовані, не гнучкі та складні у налаштуванні. Адміністрація готельних мереж стикається з низкою проблем, серед яких складність ведення обліку про готелі мережі, готельні номери, пристрої для управління кліматом, встановлені у цих номерах, та клієнтів, які проживають у готелях. Також складним завданням є планування технічного обслуговування пристроїв для управління кліматом та аналіз інформації про їх стан, оскільки без впровадження необхідних програмних систем відсутнє централізоване джерело інформації, з якого можна було б отримати дані про стан кліматичних пристроїв.
Щодо клієнтів готельних мереж, то вони з низкою проблем, серед яких необхідність керувати декількома пристроями (кондиціонери, термостати, зволожувачі) з різних інтерфейсів, складність створення та автоматизації сценаріїв роботи, що враховують індивідуальні потреби користувачів, необхідність постійно знову налаштовувати клімат у номері при подорожах через відсутність можливості синхронізації уподобань користувачів між різними закладами однієї готельної мережі.
Впровадження програмної системи з управління кліматом з можливістю синхронізації персональних профілів має допомогти подолати вищеперелічені проблеми, пропонуючи низку переваг як і для готельних мереж, які приймуть рішення про впровадження відповідної системи, так і для клієнтів таких готельних мереж безпосередньо. Головною перевагою для готельних мереж є збільшення лояльності клієнтів до певної готельної мережі завдяки синхронізації кліматичних уподобань гостей. Серед переваг для клієнтів готельних мереж можемо виділити наступні: зручне та централізоване керування кліматом, персоналізацію та адаптацію до потреб користувача, спрощення процесу акліматизації для людей, які часто подорожують.


1.1.2 Бізнес-можливості


Існує низка продуктів, які можна вважати аналогами розроблюваної системи. Серед них можемо виділити:
‒	Metasys від Johnson Controls [1] – це система диспетчеризації будівель, яка використовується для управління ОВК, освітленням та протипожежною безпекою в комерційних та промислових об'єктах. Серед плюсів системи можемо виділити масштабованість, оскільки Metasys може бути розширена, щоб відповідати потребам будь-якого об'єкта, від невеликих офісів до великих промислових комплексів. Серед недоліків можемо виділити відсутність персоналізації та орієнтації на окремого споживача, що унеможливлює використання даної системи в готельному бізнесі;
‒	Nest від Google [2] - це екосистема розумних домашніх пристроїв, які допомагають керувати кліматом домівки. До екосистеми Nest входять термостати, камери, розумні дзвоники та динаміки. Серед переваг системи можемо виділити простоту використання, оскільки усіма елементами системи можна зручно управляти використовуючи мобільний застосунок, та широкі можливості для персоналізації налаштувань системи. Серед недоліків – низьку масштабованість системи, адже вищезгадана система призначена насамперед для особистих будинків та невеликих домогосподарств, що унеможливлює її використання для великих готельних мереж.
Також варто зазначити, що обидві вищеперелічені програмні системи мають докорінний недолік – вони використовують закриті протоколи обміну даними між розумними пристроями, що унеможливлює інтеграцію пристроїв управління кліматом від сторонніх виробників з цими продуктами. Тоді як розроблювана система покликана вирішити цю проблему, пропонуючи рішення, яке стане у нагоді як і кінцевим користувачам системи (готельним мережам) так і виробникам розумних пристроїв для управління кліматом, що, зокрема, дозволить отримувати прибуток від обох сторін.
Цільовий ринок розроблюваної системи – це готелі всіх розмірів. Впровадження такої системи буде особливо корисним для готельних мереж, які прагнуть підвищити лояльність клієнтів і зробити перебування гостей більш комфортним. 
Сфера використання дозволяє продукту орієнтуватись на глобальний ринок з особливою увагою до розвинених країн Європи та Америки з високим рівнем туризму. 
Існують широкі можливості для монетизації подібного продукту, зокрема надання ліцензії з обмеженим терміном дії (в 2, 3 чи 5 років) чи постійної ліцензії на використання на основі одноразового платежу, використання даного проєкту як SaaS на основі щомісячної чи щорічної підписки.


1.1.3 Бізнес-цілі та критерії успіху


ВО-1: Збільшити лояльність клієнтів до готельної мережі
‒	SC-1: Збільшити на 10% повторне бронювання номерів протягом року після впровадження програмного забезпечення;
‒	SC-2: Збільшити на 5% середній бал задоволеності клієнтів готельними номерами протягом року після впровадження програмного забезпечення;
‒	SC-3: Знизити на 10% кількість скарг на некомфортний клімат у номері протягом року після впровадження програмного забезпечення.
ВО-2: Спростити процес акліматизації для людей, що часто подорожують
‒	SC-1: Зменшити на 20% час, необхідний для налаштування комфортного клімату в номері;
‒	SC-2: Збільшити на 15% рівень задоволеності клієнтів зручністю налаштування клімату;
‒	SC-3: Знизити на 5% кількість випадків застуди серед клієнтів протягом року після впровадження програмного забезпечення.
ВО-3: Збільшити доходи готельної мережі
‒	SC-1: Збільшити на 5% середній чек за рахунок додаткових послуг, пов'язаних з системою (наприклад, платні профілі з розширеними налаштуваннями);
‒	SC-2: Збільшити на 2% кількість бронювань номерів через мобільний застосунок готельної мережі.


1.1.4 Потреби клієнтів та ринку


Можемо виділити такі потреби клієнтів:
‒	персоналізація та контроль, що включає в себе зручне налаштування та контроль параметрів клімату (температура, вологість, вентиляція) у номері готелю, збереження та організацію персональних профілів з налаштуваннями клімату;
‒	синхронізація профілів, що включає в себе можливість синхронізації персональних профілів між різними готелями мережі, зручність для людей, що часто подорожують та мають звичні налаштування клімату;
‒	спрощення акліматизації, що включає в себе зменшення дискомфорту та стресу від зміни клімату при подорожах, швидке й зручне налаштування звичних параметрів клімату в номері.
Серед потреб ринку, можемо виділити такі:
‒	збільшення лояльності клієнтів, що включає в себе створення унікального та зручного сервісу, який відрізняє готель від конкурентів, підвищення лояльності клієнтів до певної готельної мережі;
‒	підвищення комфорту клієнтів, що включає в себе створення та підтримка оптимального мікроклімату в номері згідно з індивідуальними вподобаннями клієнтів, покращення сну, відпочинку та загального самопочуття клієнтів.


1.1.5 Бізнес-ризики


Одним з бізнес-ризиків для даного проєкту є технологічні зміни, оскільки галузь готельного бізнесу постійно розвивається, і нові технології можуть зробити наявні рішення застарілими. Щоб мінімізувати ризик втрати актуальності, важливо:
‒	розробити програмне забезпечення, яке можна легко адаптувати до нових технологій;
‒	слідкувати за трендами в готельному бізнесі та інтегрувати нові технології, які відповідають потребам клієнтів;
‒	створити партнерські відносини з іншими технологічними компаніями, щоб мати доступ до нових розробок.
Також бізнес-ризиком для розроблюваної системи є законодавчі обмеження, оскільки збір та зберігання особистих даних клієнтів регулюється законодавством у різних країнах. Щоб уникнути ризику порушення законів, важливо:
‒	розробити політику конфіденційності, яка відповідає GDPR та іншим законодавчим актам;
‒	отримати згоду клієнтів на збір та зберігання їхніх особистих даних;
‒	забезпечити безпечне зберігання даних клієнтів.
 
1.2 Концепція рішення
1.2.1 Окреслення концепції


«Програмна система управління кліматом у готельній мережі з можливістю синхронізації персональних профілів» – це продукт, заснований на відритих протоколах обміну даними між розумними пристроями управління кліматом, який призначений для готельних мереж усіх розмірів. Впровадження такої системи надає можливість клієнтам готелю:
‒	зручно налаштовувати клімат у власному номері;
‒	зберігати та організовувати свої уподобання у вигляді особистих профілів;
‒	синхронізувати профілі між різними закладами готельної мережі.
Також впровадження такої системи дає можливість готельним мережам:
‒	підвищити задоволеність клієнтів завдяки персоналізації та зручності управління кліматом шляхом використання системи;
‒	збільшити лояльність клієнтів, оскільки гості, які вже налаштували комфортний клімат у своєму номері та знають, що їм не доведеться робити цього ще раз, ймовірніше, знову зупиняться у цьому готелі;
‒	отримати перевагу у конкурентній боротьбі з іншими готельними мережами.
Щодо функціональності системи, то серверна частина програмної системи має забезпечувати безпечне зберігання даних про користувачів, готелі та налаштування клімату завдяки використанню надійних методів автентифікації та авторизації, обмеженню доступу до даних лише авторизованим користувачам хешування паролів, та резервному копіюванню даних. Також серверна частина проєкту має забезпечувати обробку запитів на синхронізацію кліматичних профілів та зберігання інформації про розумні пристрої управління кліматом, які використовують клієнти готелів.
IoT-частина проєкту має стати зв’язною частиною між серверною частиною проєкту та розумними пристроями для управління клімату, а саме вона відповідатиме за отримання команд на зміну клімату від серверної частини, передачу відповідних вказівок до розумних пристроїв з використанням відкритих протоколів та уніфікованого інтерфейсу обміну даними та обробку критичних ситуацій, наприклад, помилкові відповіді пристроїв для управління кліматом на запит про зміну клімату.
Браузерна та мобільна частини системи призначені для надання зручного інтерфейсу для використання системи, функціонал браузерного застосунку також буде розширено можливостями для адміністрування системи, що включає у себе можливості для створення резервних копій бази даних, експорт та імпорт даних тощо.


1.2.2 Головна функціональність


До головної функціональності можемо віднести:
‒	MF-1 персоналізоване управління кліматом: впровадження програмної системи управління кліматом з можливістю синхронізації персональних профілів дозволить клієнтам готелю зручно налаштовувати клімат у власному номері;
‒	MF-2 синхронізація кліматичних профілів клієнтів готелю: програмна система також надаватиме можливість синхронізувати налаштування клієнтів між готелями однієї мережі, що підвищить лояльність клієнтів до готельної мережі та спростить процес акліматизації;
‒	MF-3 попередження виходу з ладу пристроїв для управління кліматом: IoT-пристрій автоматично повідомлятиме адміністрацію готелю про вихід з ладу пристроїв для управління кліматом у готельних номерах, що дозволить своєчасно реагувати на критичні ситуації такого роду та підтримувати комфорт клієнтів готелю на високому рівні.


1.2.3 Припущення та залежності


Можемо виділити такі припущення:
‒	AS-1: Користувачі готелів зацікавлені у налаштуванні та синхронізації персональних профілів для керування кліматом у номері;
‒	AS-2: Готельна мережа готова інтегрувати програмне забезпечення з системами управління кліматом у номерах;
‒	AS-3: Користувачі погодяться на збір та обробку персональних даних, необхідних для роботи системи;
‒	AS-4: Мобільні пристрої користувачів сумісні з програмним забезпеченням;
‒	AS-5: Готельна мережа має стабільне підключення до мережі Інтернет у всіх закладах.
Можемо навести такі залежності:
‒	DE-1: Коректна робота системи залежить від сумісності з системами управління кліматом у номерах;
‒	DE-2: Ефективність синхронізації профілів залежить від стабільного підключення до мережі Інтернет у користувачів;
‒	DE-3: Зручність використання програмного забезпечення залежить від дизайну та інтуїтивності мобільного додатку;
‒	DE-4: Рівень лояльності клієнтів до готельної мережі залежить від загального досвіду використання програмного забезпечення.
 
1.3 Рамки та обмеження
1.3.1 Рамки первинного випуску


У рамках первинного випуску планується реалізація низки ключових функцій, які забезпечать зручність керування кліматом у готельних номерах. Щодо загальних можливостей системи, до первинного випуску буде включено можливості для управління кліматом у номері, включаючи управління температурою та вологістю, збереження уподобань клієнтів у вигляді персональних профілів, синхронізацію профілів клієнтів готелю між різними закладами готельної мережі, локалізація застосунку українською та англійською мовами.
Щодо серверної частини проєкту, до первинного випуску буде включено функції автентифікації та авторизації готельних мереж, які бажають встановити дану систему, зберігання даних про їх клієнтів та прилади для управління кліматом, встановлені у готельних номерах, зберігання кліматичних уподобань клієнтів готелю у вигляді персональних профілів та їх синхронізацію. Безпека зберігання даних на сервері та обміну даними між різними частинами системи буде досягатись шляхом обмеження доступу до даних для користувачів, які не пройшли процедуру авторизації, хешуванням паролів та кодів доступу.
В рамках первинного випуску продукту клієнтська та мобільна частини системи, надаватимуть візуальний інтерфейс для керування кліматом у готельному номері, створення та збереження персональних кліматичних профілів. Функціонал браузерного застосунку буде розширено можливостями для адміністрування системи, включно з можливостями для створення резервних копій бази даних, імпорту та експорту даних тощо.
IoT частина системи, в рамках первинного релізу відповідатиме за отримання команд на зміну клімату від серверної частини, передачу відповідних вказівок до розумних пристроїв з використанням відкритих протоколів та уніфікованого інтерфейсу обміну даними та обробку критичних ситуацій, наприклад, помилкові відповіді пристроїв для управління кліматом на запит про зміну клімату. Обробка помилкових ситуацій включатиме в себе автоматичне повідомлення про такі ситуації адміністрації готелю, що надаватиме можливість на них своєчасно реагувати.


1.3.2 Рамки наступних випусків


У рамках подальших випусків системи її функціонал може бути розширено можливостями для голосового управління кліматом у номері, прогнозування та передбачення виходу з ладу пристроїв для управління кліматом у номері, звітністю щодо енергоефективності готельних номерів та інтеграцією штучного інтелекту для автоматичної генерації кліматичних профілів.


1.3.3 Обмеження та винятки


‒	Для коректної роботи система потребує постійного підключення до мережі Інтернет;
‒	в рамках первинного випуску продукту, система буде лише для мобільних пристроїв на базі Android;
‒	в рамках первинного випуску інтерфейс системи буде локалізовано лише українською та англійською мовами;
 
1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


Таблиця 1.4.1 – Профілі зацікавлених сторін
Зацікавлена сторона	Обмеження	Основні інтереси	Ставлення до програмного продукту	Основна цінність
Клієнти готелю	Потреба в постійному під'єднанні до мережі, потреба у придбанні ІоТ приладів	Можливість персонального налаштування клімату, 
спрощення процесу акліматизації завдяки комфортному клімату в номері	Бажає отримати інформативний та простий у використанні застосунок	Можливість  вільно керувати кліматом з будь-якого місця, синхронізація налаштувань між різними готелями
Власник готелю	Бюджетні обмеження, ризики, пов'язані з впровадженням нового програмного забезпечення	Можливість покращити імідж готелю та підвищити лояльність клієнтів до своєї готельної мережі	Очікує, що система буде приносити прибуток та підвищувати лояльність клієнтів	Збільшення лояльності клієнтів, збільшення прибутку, підвищення конкурентності готелю
Зацікавлена сторона	Обмеження	Основні інтереси	Ставлення до програмного продукту	Основна цінність
Розробники	Технічна специфікація, бюджет розробки	Створення продукту, який повністю відповідав би вимогам замовника	Чекає на відгуки клієнтів для покращення продукту	Кількість користувачів, їх враження про продукт
Інвестори	Бізнес-ризики, фінансовий ресурс	Власний прибуток	Ставиться до продукту як до ресурсу, який може повернути та примножити інвестиції	Стабільність прибутків, репутація продукту


1.4.2 Пріоритети проєкту


Таблиця 1.4.2 – Пріоритети проєкту
Вимір	Драйвер	Обмеження	Ступінь свободи
Графік робіт	Випуск версії 1.0 проєкту має прийтись на травень 2024 року	Дата випуску проєкту – 5 місяць 2023 року.	Максимальна затримка випуску версії 1.0 проєкту – 30 днів


Вимір	Драйвер	Обмеження	Ступінь свободи
Функціональність	Перший випуск системи повинен мати мінімальний набір необхідного функціоналу, описаний у пункті 3.1	Набір функцій, доступний у першому випуску продукту	З первинного випуску може бути виключена локалізація українською мовою
Якість	Готові модулі системи мають проходити 100% функціональних тестів	Відсоток проходження функціональних тестів	Відсоток проходження тестів – 100%.
Персонал	Максимальний розмір команди – 1 розробник	Максимальний розмір команди.	Залучення додаткових розробників неможливе
Бюджет	На створення проєкту не передбачено додаткових витрат	Наявні грошові ресурси	Розширення бюджету неможливе


1.4.3 Робоче середовище


Для розробки серверної частини системи було обрано фреймворк NestJS, який має вбудовані механізми автентифікації та авторизації, що забезпечать безпечний доступ до API.
Для зберігання даних було обрано СУБД PostgreSQL, яка має вбудовані механізми резервного копіювання та відновлення даних, що допоможе забезпечити відповідність вимогам до надійності та стійкості системи до аварійних ситуацій.
Для розробки браузерного застосунку було обрано бібліотеку React, який відповідає вимогам до безпеки системи (зокрема, вимогам до захисту від XSS-атак шляхом використання бібліотеки DOMPurify у своїх внутрішніх механізмах). Для спрощення асинхронної взаємодії із сервером та синхронізації стану серверного і браузерного застосунків було обрано стейт-менеджер MobX.
Для розробки мобільного застосунку було обрано фреймворк Jetpack Compose для мови програмування Kotlin.
Система буде використовуватися клієнтами готелів, які знаходяться по всьому світу. Це означає, що користувачі будуть географічно розпорошені і знаходитися в різних часових поясах.
Користувачі зможуть отримати доступ до системи через веб-інтерфейс та мобільний додаток. Очікується, що доступ до системи буде необхідний цілодобово, 7 днів на тиждень.
Дані про налаштування клімату, особисті профілі та інші дані користувачів будуть зберігатися на сервері. Дані IoT-пристроїв про температуру, вологість та інші параметри середовища також будуть надсилатися на сервер.
 
2 ПРОЄКТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ


2.1 Опис архітектури системи


Загалом система складатиметься з 5 основних компонентів, серед яких серверна частина, IoT-пристрій, браузерний та мобільний клієнт й окрема хмарна база даних.
Серед користувачів системи можемо виділити дві основні ролі: адміністрація готельної мережі та клієнти готельної мережі.
Щодо функціональних можливостей системи, то адміністратори готельних мереж повинні мати змогу реєструвати у системи власну готельну мережу, додавати інформації про готелі, готельні номери та пристрої управління кліматом, встановлені у готельних номерах, вносити у систему інформацію про клієнтів мережі у момент їх заселення у готель. Також адміністратори готельних мереж повинні мати змогу отримувати статистику за пристроями для управління кліматом, встановленими у готельних номерах, та виробниками таких пристроїв.
Клієнти готельних мереж повинні мати змогу реєструватись у системі, керувати персональними кліматичними профілями та встановлювати кліматичні профілі як активні чи неактивні.


2.2 Побудова діаграми розгортання


Протягом проєктування системи було прийнято рішення винести базу даних в окремий компонент системи, який буде розгорнуто за допомогою у хмарі за допомогою послуг хмарного провайдера, яким, наприклад, може стати AWS.
Серверний застосунок також планується розгорнути у хмарі з використанням послуг хмарного провайдера. Зв’язок між серверним застосунком та базою даних підтримуватиметься на основі протоколу, розробленого командою PostgreSQL, який побудовано над TCP/IP.
Мобільний та браузерний клієнти підтримуватимуть зв’язок з серверною частиною системи використовуючи HTTPS-запити.
Для синхронізації даних серверного застосунку та IoT-пристрою було обрано технологію Long polling, яка працює на основі протоколу HTTPS.
Результатом проєктування стала діаграма розгортання системи (рис. А.1).
 
3 РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ СИСТЕМИ
3.1 Опис архітектури серверної частини системи


Протягом проєктування було прийнято рішення за основу для розробки серверної частини проєкту обрати монолітну N-шарову архітектуру, як таку, що забезпечить швидкодію системи завдяки мінімальним накладним витратам на обмін між окремими частинами системи.
Відповідно до принципів N-шарової архітектури, серверний застосунок було розділено на три шари: шар представлення, шар бізнес-логіки та шар доступу до даних.
Шар представлення описано класами-контролерами, до обов’язків яких входить обробка зовнішніх HTTP-запитів, передача виклику нижче за ланцюжком до рівня бізнес-логіки та формування відповіді клієнту.
Шар бізнес-логіки представлено класами-сервісами, у яких сконцентровані необхідні для оброки користувацьких запитів. 
Шар доступу до даних даних представлений класами-репозиторіями, які надаються зовнішньою бібліотекою TypeORM та відповідають на запити з отримання чи збереження даних.
Для збереження слабкої зв’язності компонентів системи було використано шаблон проєктування впровадження залежностей (Dependency injection).
 
3.2 Побудова діаграми прецедентів для серверної частини системи


В рамках розробки серверного застосунку було проведене концептуальне моделювання системи.
Адміністратори системи повинні мати змогу створювати обліковий запис для власної готельної мережі, додавати інформацію про заклади готельної мережі, номери у закладах та пристрої управління кліматом, встановлені у даних номерах, а також додавати інформацію про клієнтів готельних мереж у момент їх заселення та вносити інформацію про статус проживання клієнта в готелі (проживає у певному готельному номері або не проживає у готелі). Також адміністратори готельних мереж повинні мати змогу отримувати статистику за пристроями для управління кліматом, встановленими у готельних номерах, та виробниками таких пристроїв.
Клієнти готельних мереж повинні мати змогу створювати персональний акаунт, додавати інформацію про персональні кліматичні профілі та вносити інформацію про поточний статус кліматичного профіля (активний або неактивний). Система повинна правильно оброблювати ситуації проживання декількох людей в одному готельному номері, що включає в себе генерацію попереджень в момент, коли один зі співмешканців намагається встановити кліматичний профіль активним за умови, що в даному готельному номері вже встановлено активний кліматичний профіль.
В результаті концептуального проєктування системи було створено діаграму прецедентів для адміністрації готельної мережі (рис. А.2) та клієнта готельної мережі (рис. А.3).





3.3 Побудова ER-діаграми для серверної частини системи


На основі концептуального моделювання системи було виділено низку стрижневих сутностей системи, перелік яких наведено нижче.
Сутність «Компанія», зберігає інформацію про готельну мережу, серед якої назва, пошта для зв’язку з компанією (наприклад, для отримання повідомлень про помилку активації кліматичного профіля у номері) та геш паролю для авторизації.
Сутність «Готель», зберігає у собі інформацію про готель у складі готельної мережі, серед якої назва готелю та його адреса. Пов’язана ця сутність з сутністю «Компанія» зв’язком «багато до одного».
Сутність «Кімната» зберігає у собі інформацію про готельний номер, серед якої номер готелю. Пов’язана ця сутність з сутністю «Готель» зв’язком «багато до одного».
Сутність «Пристрій для керування кліматом» зберігає у собі інформацію про пристрої керування кліматом, встановлені у готельних номерах, серед якої тип пристрою для керування кліматом (на даний момент підтримується взаємодія з термостатами та гігростатами), IP-адреса пристрою в локальній мережі готельного номера для зв’язку IoT-пристрою з даним пристроєм для управління кліматом та його статус (ОК, є незначні проблеми, критичний стан). Пов’язана ця сутність з сутністю «Кімната» зв’язком «багато до одного».
Сутність «Клієнт» зберігає у собі інформацію про клієнта готельної мережі, серед якої ім’я клієнта, його пошта. Пов’язана ця сутність з сутністю «Кімната» зв’язком «жодного або багато до одного».
Сутність «Кліматичний профіль» зберігає у собі інформацію про набір кліматичних налаштувань, які клієнт готельної мережі вирішив винести в окремий профіль, серед якої назва профілю, рівень температури, рівень вологості, та позначка про те, чи є профіль активним на даний момент. Пов’язана ця сутність з сутністю «Клієнт» зв’язком «жодного або багато до одного».
Результатом проєктування системи стала ER-діаграма, яку наведено у додатку А.4.


3.4 Специфікація REST


Автентифікація та авторизація:
‒	POST auth/google/signin – реєстрація та авторизація клієнтів готельних мереж за допомогою Google OAuth;
‒	POST auth/signup/company – реєстрація облікового запису готельної мережі;
‒	POST auth/signin/company – авторизація адміністрації готельної мережі в рамках системи;
Робота з клієнтами готельних мереж:
‒	GET clients/:id – отримання клієнта за ідентифікатором у базі даних;
‒	POST clients/ – створення нового клієнта;
‒	PATCH clients/:id – оновлення інформації про клієнта за ідентифікатором у базі даних;
‒	DELETE clients/:id – видалення клієнта за ідентифікатором у базі даних;
Робота з готелями:
‒	GET hotels/ – отримання списку готелів;
‒	GET hotels/:id – отримання готелю за ідентифікатором у базі даних;
‒	POST hotels/ – створення нового готелю;
‒	PATCH hotels/:id – оновлення інформації про готель за ідентифікатором у базі даних;
‒	DELETE hotels/:id – видалення готелю за ідентифікатором у базі даних;
Робота з пристроями для управління кліматом:
‒	GET climate-devices/ – отримання списку пристроїв для управління кліматом;
‒	GET сlimate-devices/:id – отримання пристрою для управління кліматом за ідентифікатором у базі даних;
‒	POST climate-devices/ – створення нового готелю;
‒	PATCH climate-devices/:id – оновлення інформації про пристрій для управління кліматом за ідентифікатором у базі даних;
‒	DELETE climate-devices/:id – видалення пристрою для управління кліматом за ідентифікатором у базі даних;
Робота з кліматичними профілями:
‒	GET climate-profiles/ – отримання списку кліматичних профілів;
‒	GET сlimate-profiles/:id – отримання кліматичного профіля за ідентифікатором у базі даних;
‒	POST climate-profiles/ – створення нового кліматичного профіля;
‒	PATCH climate-profiles/:id – оновлення інформації про кліматичний профіль за ідентифікатором у базі даних;
‒	DELETE climate-profiles/:id – видалення кліматичного профілю за ідентифікатором у базі даних;
Робота з готельними мережами:
‒	PATCH companies/:id – оновлення інформації про готельну мережу за ідентифікатором у базі даних;
Робота з готельними номерами:
‒	GET rooms/ – отримання списку готельних номерів;
‒	GET rooms/:id – отримання готельного номеру за ідентифікатором у базі даних;
‒	POST rooms/ – створення нового готельного номеру;
‒	PATCH rooms/:id – оновлення інформації про готельний номер за ідентифікатором у базі даних;
‒	DELETE rooms/:id – видалення готельного номеру за ідентифікатором у базі даних;
‒	GET rooms/number-by-id – отримання номеру кімнати за її ідентифікатором у базі даних;
‒	GET rooms/active-profile – отримання активного кліматичного профіля для номера;
‒	POST rooms/set-profile-active – встановлення кліматичного профіля активним для готельного номера;
Робота зі статистикою:
‒	GET stats/climate-devices – отримання статистики за кліматичними пристроями для готельної мережі;
‒	GET stats/climate-devices/hotel/:hotelId – отримання статистики за кліматичними пристроями для певного готелю;
GET stats/manufacturers – отримання статистики за вирбониками кліматичних пристроїв;
Варто зауважити, що усі групи точок входу, окрім точок входу для авторизації та автентифікації, потребують передачі токену доступу в авторизаційних заголовках запиту, за допомогою чого серверна частина системи отримуватиме інформацію про користувача, який здійснює запит. При відсутності токена доступу сервер повертатиме помилку 401 Unauthorized. При порушенні структури токена доступу або недостатній кількості прав користувача, сервер повертатиме помилку 403 Forbidden.
 
3.5 Побудова діаграми пакетів


Для розподілу серверного застосунку на окремі пакети було використано підхід Feature-slice design.
Цей підхід передбачає створення одного головного пакету, який стає точкою входу в застосунок, і окремих пакетів для кожної з основних функцій системи.
Точкою входу в застосунок став пакет App, в якому відбувається імпорт решти пакетів, конфігурація застосунку, підключення middlewares та власне запуск застосунку.
Далі для кожної з основних функцій системи, до списку яких входить авторизація та автентифікація, робота з клієнтами, робота з кліматичними пристроями, робота з кліматичними профілями, робота готелями, робота з готельними номерами було створено відповідні пакети: auth, clients, climate-devices, climate-profiles, companies, hotels, rooms. 
Кожен з цих пакетів (які також називаються слайсами) включає в себе 3 файли: контролер, сервіс та модуль (використовується для налаштування впровадження залежностей).
Також, кожен з цих пакетів включає в себе низку підпакетів. Далі наведено загальний перелік можливих підпакетів у слайсі:
‒	entities – список сутностей, з якими проводиться робота в даному слайсі;
‒	dto – описує Data transfer objects, сутності, які задають формат обміну даними між серверним застосунком та клієнтами;
‒	types – містить у собі файли з деклараціями типів, що перевикористовуються в рамках даного слайса.
За необхідності у слайсі також можуть створюватись додаткові підпакети. Детальніше структуру пакетів застосунку відображено на рисунку А.5.
 
4 РОЗРОБКА ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ ДЛЯ ВБУДОВАНИХ СИСТЕМ
4.1 Концептуальне моделювання системи


Перед розробкою програмного забезпечення для IoT-пристрою в рамках програмної системи для управління кліматом у готельній мережі з можливістю синхронізації персональних профілів необхідно провести концептуальне моделювання системи.
В рамках системи IoT-пристрій виступатиме зв’язною ланкою між серверною частиною системи та пристроями для управління кліматом, встановленими в готельних номерах.
Відповідно, IoT-пристрою необхідно буде отримувати від серверної частини дані про готельний номер, в якому встановлено IoT-пристрій, список пристроїв для управління кліматом, встановлених у готельному номері та активний кліматичний профіль. На основі цих даних IoT-пристрій готуватиме запит на зміну кліматичних налаштувань для пристроїв для управління кліматом та надсилатиме його.
На основі відповіді, отриманої від пристроїв для управління кліматом, на випадок виникнення критичної ситуації, IoT-пристрій генеруватиме попередження для адміністрації готелю у вигляді листа на пошту, до якого буде включено інформацію про готельний номер та пристрій для управління кліматом, в роботі якого виникла помилка, з метою надання адміністрації готелю можливості коректно відреагувати на критичну ситуацію.
Результатом концпетуального моделювання системи стала UML діаграма прецедентів, наведена у додатку А.6.





4.2 Опис роботи застосунку для вбудованих систем
4.2.1 Опис архітектурних рішень проєкту


За основу для розробки програмного забезпечення для IoT-пристрою в рамках розроблюваної системи стала монолітна архітектура, як така, що дозволить забезпечити оптимальний обмін даними між різноманітними компонентами системи без додаткових витрат продуктивності, як це може відбуватись у мікросервісних системах, що стало б вагомим недоліком системи за умов обмеженої обчислювальної потужності IoT-пристрою.
Обмін даними між IoT-пристроєм та серверним застосунком в рамках системи відбуватиметься на основі технології Long Polling, що заснована на протоколі HTTP. Використання цієї технології дозволить уникнути створення та підтримання постійного каналу зв’язку між сервером та IoT-пристроєм, що матиме позитивний вплив на продуктивність цих двох компонентів системи.
Детальніше взаємодію IoT-пристрою та серверного застосунку продемонстровано у UML діаграмі взаємодії, яку наведено в додатку А.7


4.2.2 Опис використаних технологій


Цільовою платформою для запуску програмного забезпечення для IoT-пристрою став мікроконтролер ESP32 з підтримкою діалекту мови Python Micropython. Для спрощення процесу розробки для симуляції роботи вищезазначеного мікроконтролера було використано веб-застосунок Wokwi.
Протягом розробки застосунку для IoT-пристрою використовувалась низка бібліотек зі стандартного набору бібліотек ESP32, зокрема urequests для здійснення веб-запитів до серверу, ujson для обробки json-відповідей від сервера та network для підключення пристрою до локальної мережі готельного номеру тощо.
Окрім перелічених вище бібліотек зі стандартного набору ESP32 також були використані зовнішні бібліотеки, зокрема umail для відправки поштових повідомлень та logging для логування роботи IoT-пристрою. Код зовнішніх бібліотек було включено у вихідний код в якості окремих модулей застосунку.
Детальніше структуру розробленого застосунку наведено в UML діаграмі пакетів (рис. А.8).


4.2.3 Опис результатів розробки ПЗ для вбудованих систем


Результатом розробки програмного забезпечення для IoT-пристрою став застосунок, який забезпечує взаємодію між серверною частиною системи та пристроями для управління кліматом у готельних номерах.
Під час запуску пристрою проводиться його початкова конфігурація, зокрема зчитування налаштувань з конфігураційного файлу. Після чого починається основний цикл програми.
В основному циклі IoT-пристрій отримує інформацію про готельний номер, в якому його встановлено, список пристроїв для управління кліматом, встановлених у готельному номері та поточний активний кліматичний профіль.
На основі цих даних пристрій формує запити на зміну параметрів клімату до кожного з пристроїв управління кліматом, встановлених у номері та оброблює відповіді, надані вищеназваними пристроями.
Якщо у відповіді зазначено статус «Попередження» або «Помилка», IoT-пристрій генерує попередження для адміністрації готелю, до якого включено інформацію про готельний номер та пристрій для управління кліматом, в роботі якого виникла помилка, з метою надання адміністрації готелю можливості коректно відреагувати на критичну ситуацію. Створене попередження надсилається адміністрації готелю у вигляді поштового повідомлення за допомогою протоколу SMTP.
Детальніше принцип роботи IoT-пристрою наведено в UML діаграмі діяльності (рис. А.9).


4.2.4 Опис результатів тестування ПЗ для вбудованих систем


Функціональне тестування  розробленого застосунку проводилось вручну, з використанням веб-емулятора Wokwi для спрощення процесу тестування.
Проведення функціонального тестування системи дозволило забезпечити стійкість системи до критичних ситуацій та упевнитись в стабільності роботи розробленого застосунку.
 
5 РОЗРОБКА КЛІЄНТСЬКОГО ВЕБ-ЗАСТОСУНКУ
5.1 Концептуальне моделювання системи


Перед розробкою програмного забезпечення для браузерного клієнтського застосунку в рамках програмної системи для управління кліматом у готельній мережі з можливістю синхронізації персональних профілів необхідно провести концептуальне моделювання системи.
В рамках роботи з браузерним клієнтом для програмної системи адміністратору готельної мережі необхідно буде мати можливість управління готелями, що включає в себе перегляд усіх готелів, створення, редагування інформації про та видалення готелю. Також адміністратору готельної мережі необхідно мати можливість управління готельними номерами, пристроями для управління кліматом та клієнтами готельної мережі. Також адміністратору готельної мережі необхідно мати можливість перегляду статистики за кліматичними пристроями встановленими в усіх або конкретному готелі готельної мережі та статистику за виробниками пристроїв для управління кліматом.
Результатом концпетуального моделювання системи стала UML діаграма прецедентів, наведена у додатку А.2.

5.2 Опис розробки клієнтського веб-застосунку
5.2.1 Обґрунтування архітектурних рішень проєкту


За основу для розробки програмного забезпечення для браузерного клієнтського застосунку в рамках системи було обрано багатошарову архітектуру.
Серед окремих шарів системи можемо виділити шар відображення (Presentation layer), представлений компонентами користувацького інтерфейсу. Компонентний підхід до розробки шару відображення забезпечує можливість перевикористання окремих атомарних компонентів, що відкриває шлях до простого та ефективного перевикористання коду.
	У шар бізнес-логіки (Business Logic layer) було виокремлено логіку по роботі з даними та управління глобальним станом застосунку. Представлено шар бізнес-логіки класами-сховищами (store). Створення окремого шару бізнес-логіки дало можливість прибрати логіку з обробки даних з компонентів користувацького інтерфейсу та зосередити в них виключного логіку з відображення даних.
У шарі доступу до даних (Data Access layer) або шарі API сконцентровано логіку для отримання даних від серверної частини. Представлено шар класами-api.
Перевагами використання багатошарової архітектури для створення клієнтських застосунків є ізоляція схожої логіки в окремих модулях та можливість забезпечення низкьої зв’язанності між шарами системи, що значно спрощує заміну відповідних шарів за потреби, оскільки задля заміни одного шару нема необхідності вносити зміни в інші. Наприклад, задля переходу з протоколу http на протокол websockets задля створення функціоналу реального часу в застосунку достатньо буде внести зміни виключно у шар доступу до даних, тоді як BLL та PL лишаться без змін.
Результатом проєктування архітектури системи стала UML діаграма компонент, наведена у додатку А.10.


5.2.2 Опис використаних технологій


Основою для створення шару представлення та описання користувацького інтерфейсу шляхом створення окремих незалежних компонентів у декларативному стилі стала бібліотека React. Задля спрощення, пришвидшення розробки та уникнення реалізації шаблонних компонентів було використано компонентну бібліотеку Ant Design.
Основою для створення шару бізнес-логіки стала бібліотека для управління станом додатку Mobx.
Основою для створення шару доступу до даних стала бібліотека для здійснення HTTP запитів Axios. Для обміну даними між серверною частиною системи та браузерним клієнтом використовується протокол HTTPS. 
Для забезпечення локалізації додатку було використано бібліотеку i18next та її адаптер для React react-i18next.
Детальніше структуру розробленого застосунку наведено в UML діаграмі пакетів (рис. А.11).


5.2.3 Опис результатів розробки клієнтського веб-застосунку


Результатом розробки програмного забезпечення для браузерної клієнтської частини системи став застосунок, який надає адміністрації готельної мережі можливість ефективного управління власною готельною мережою.
Протягом першого запуску застосунку користувачеві буде запропоновано створити новий обліковий запис або увійти в уже створений обліковий запис. Задля отримання доступу до основного функціоналу застосунку необхідно пройти процес автентифікації.
Автентифікованому користувачу надається доступ до розділів «Готелі», «Користувачі» та «Статистика» за допомогою меню навігації у шапці сайту.
Розділ «Клієнти» надає користувацький інтерфейс для управління клієнтами готельної мережі, що включає в себе перегляд списку клієнтів, а також створення, редагування інформації про та видалення клієнтів. Інформація про кожного клієнта надається у вигляді карточки.
Розділ «Статистика» надає користувацький інтерфейс для перегляду статистики за кліматичними пристроями та виробниками кліматичних пристроїв. Статистику за кліматичними пристроями наведено у вигляді переліку кількості кліматичних пристроїв у кожному можливому стані (задовільний, попередження, помилка) та відсоткового співвідношення кількості кліматичних пристроїв у певному стані до загальної кількості. Розподіл кліматичних пристроїв за їх станом також візуалізовано у вигляді секторної діаграми. Також надається можливість фільтрації статистики за готелями. 
Статистика за виробниками кліматичних пристроїв надається у вигляді рейтингу найгірших виробників кліматичних пристроїв. Ранжування списку виробників відбувається за кількістю пристроїв у стані помилки та кількістю пристроїв у стані попередження.
Розділ «Готелі» надає користувацький інтерфейс для управління готелями, що включає в себе перегляд списку готелів, а також створення, редагування інформації про та видалення готелів. Інформація про кожен готель надається у вигляді карточки. В тілі кожної карточки розташоване посилання на сторінку для управління номерами даного готелю.
Сторінка «Номери» надає користувацький інтерфейс для управління номерами певного готелю, що включає в себе перегляд номерів, а також створення, редагування інформації про та видалення готельних номерів. Інформація про кожен готельний номер надається у вигляді карточки. В тілі кожної карточки розташоване посилання на сторінку для кліматичними пристроями, встановленими в даному готельному номерів.
Сторінка «Кліматичні пристрої» надає користувацький інтерфейс для управління кліматичними пристроями певного готельного номеру, що включає в себе перегляд списку встановлених кліматичних пристроїв, а також створення, редагування інформації про та видалення кліматичних пристроїв. Інформація про кожен кліматичний пристрій надається у вигляді карточки.
Детальніше принцип роботи браузерного клієнта наведено в UML діаграмі діяльності (рис. А.12).



5.2.4 Опис результатів тестування клієнтського веб-застосунку


Функціональне тестування розробленого застосунку проводилось вручну, з використанням браузерів Google Chrome та Mozilla Firefox останніх версій на операційній системі Windows 11.
Проведення функціонального тестування системи дозволило забезпечити її стійкість до критичних ситуацій та упевнитись в стабільності роботи розробленого застосунку.
 
6 РОЗРОБКА МОБІЛЬНОГО ЗАСТОСУНКУ
6.1 Концептуальне моделювання системи


Перед розробкою програмного забезпечення для мобільного застосунку в рамках програмної системи для управління кліматом у готельній мережі з можливістю синхронізації персональних профілів необхідно провести концептуальне моделювання системи.
В рамках роботи з мобільним застосунком для програмної системи клієнту готельної мережі необхідно буде мати можливість управління власними кліматичними профілями, що включає в себе перегляд усіх кліматичних профілів, а також створення, редагування інформації про та видалення кліматичних профілів. Також клієнту готельної мережі необхідно мати можливість встановлювати статус власних кліматичних профілів (активний/неактивний).
Результатом концпетуального моделювання системи стала UML діаграма прецедентів, наведена у додатку А.3.


6.2 Опис розробки мобільного застосунку
6.2.1 Обґрунтування архітектурних рішень проєкту


За основу для розробки програмного забезпечення для мобільного застосунку в рамках системи було обрано багатошарову архітектуру.
Серед окремих шарів системи можемо виділити шар відображення (Presentation layer), представлений компонентами користувацького інтерфейсу. Компонентний підхід до розробки шару відображення забезпечує можливість перевикористання окремих атомарних компонентів, що відкриває шлях до простого та ефективного перевикористання коду.
	У шар бізнес-логіки (Business Logic layer) було виокремлено логіку по роботі з даними та управління глобальним станом застосунку. Представлено шар бізнес-логіки класами ViewModel. Створення окремого шару бізнес-логіки дало можливість прибрати логіку з обробки даних з компонентів користувацького інтерфейсу та зосередити в них виключного логіку з відображення даних.
У шарі доступу до даних (Data Access layer) або шарі API сконцентровано логіку для отримання даних від серверної частини. Представлено шар класами-API.
Перевагами використання багатошарової архітектури для створення мобільних застосунків є ізоляція схожої логіки в окремих модулях та можливість забезпечення низкьої зв’язанності між шарами системи, що значно спрощує заміну відповідних шарів за потреби, оскільки задля заміни одного шару нема необхідності вносити зміни в інші.
Результатом проєктування архітектури системи стала UML діаграма компонент, наведена у додатку А.13.


6.2.2 Опис використаних технологій


Основою для створення шару представлення та описання користувацького інтерфейсу шляхом створення окремих незалежних компонентів у декларативному стилі став фреймворк Jetpack Compose. Задля спрощення, пришвидшення розробки та уникнення реалізації шаблонних компонентів було використано компонентну бібліотеку Material3.
Бізнес-логіку застосунку було описано у класах ViewModel. Компоненти користувацького інтерфейсу отримують доступ до необхідних ViewModel за допомогою паттерну впровадження залежностей (Dependency Injection).
Основою для створення шару доступу до даних стала бібліотека для здійснення HTTP запитів KTOR Client. Для обміну даними між серверною частиною системи та мобільним застосунком використовується протокол HTTPS. 
Застосунок підтримує українську та англійську локалізацію. Реалізовано локалізацію було за допомогою стандартних можливостей ОС Android.
Детальніше структуру розробленого застосунку наведено в UML діаграмі пакетів (рис. А.14).


6.2.3 Опис результатів розробки мобільного застосунку


Результатом розробки програмного забезпечення для мобільної клієнтської частини системи став застосунок, який надає клієнту готельної мережі можливість ефективного управління власними кліматичними профілями.
Протягом першого запуску застосунку користувачеві буде запропоновано створити новий обліковий запис або увійти в уже створений обліковий запис за допомогою власного облікового запису Google. Задля отримання доступу до основного функціоналу застосунку необхідно пройти процес автентифікації.
Автентифікованому користувачу надається доступ до сторінки управління кліматичними профілями. Дана сторінка надає користувацький інтерфейс для управління кліматичними профілями, що включає в себе перегляд список кліматичних профілів, а також створення, редагування інформації про та видалення кліматичного профіля. Інформація про кліматичні профілі надається у вигляді списку карток.
Також надається користувацький інтерфейс для управління статусом кліматичних профілів у вигляді відповідної кнопки у тілі картки з описом кліматичного профіля.
Структуру даних мобільного застосунку було продемонстровано в ER-діаграмі даних. (рис. А.15).
6.2.4 Опис результатів тестування мобільного застосунку


Функціональне тестування розробленого застосунку проводилось вручну, з використанням емулятора смартфона Google Pixel 8 з операційною системою Android 12 (версія API 31).
Проведення функціонального тестування системи дозволило забезпечити її стійкість до критичних ситуацій та упевнитись в стабільності роботи розробленого застосунку.
 
ВИСНОВКИ


На початкових етапах виконання курсового проекту було проведено аналіз та концептуальне моделювання предметної області, визначено бізнес-можливості системи, для чого було проаналізовано наявні аналоги, визначено їх сильні та слабкі сторони, що стало основою для створення власного програмного продукту.
На основі аналізу предметної області було проведене проєктування програмної системи, що включило в себе проєктування бази даних, проєктування загальної архітектури системи, процесу її розгортання та взаємозв’язку між окремими частинами системи, а також проєктування архітектури окремих частин системи, до переліку яких увійшли серверна частина, програмне забезпечечння для IoT-пристрою, клієнтський веб-застосунок та мобільний застосунок. 
На фінальних етапах виконання курсового проекту було програмно реалізовано спроектовану раніше програмну систему. Для розробки серверної частини системи було обрано фреймворк NestJS, Для зберігання даних було обрано СУБД PostgreSQL. Для розробки браузерного застосунку було обрано бібліотеку React. Для спрощення асинхронної взаємодії із сервером та синхронізації стану серверного і браузерного застосунків було обрано стейт-менеджер MobX. Для розробки мобільного застосунку було обрано фреймворк Jetpack Compose для мови програмування Kotlin.
В результаті виконання курсового проекту було створено програмну систему для управління кліматом у готельній мережі з можливістю синхронізації персональних профілів, яка може використовуватись як адміністрацією готельної мережі, так і її клієнтами. Для адміністрації готельної мережі було реалізовано функціонал управління готельною мережею, що включає в себе управління готелями, готельними номерами, пристроями для керування пристроями та клієнтами готельної мережі, а також отримання статистики за станом кліматичних пристроїв та їх виробниками з метою надання адміністрації готельної мережі можливості ефективного планування технічного обслуговування пристроїв для управління кліматом, встановлених у готельних номерах. Для клієнтів готельної мережі було реалізовано функціонал управління власними кліматичними профілями та їх синхронізації, а також управління статусом кліматичних профілів, зокрема встановлення кліматичного профіля як активний чи неактивний.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1. Вебсайт Metasys від Johnson Controls. URL: https://www.johnsoncontrols.com/building-automation-and-controls/building-automation-systems-bas (дата звернення: 12.05.2024).
2. Вебсайт Nest від Google. URL: https://store.google.com/gb/product/nest_learning_thermostat_3rd_gen?hl=en-GB (дата звернення: 12.05.2024).
3. Github-репозиторій з програмною реалізацією програмною системи. URL: https://github.com/NurePoroshkinAnton/apzkr-pzpi-21-2-poroshkin-anton (дата звернення: 23.05.2024).
4. Відео захисту курсової роботи: https://youtu.be/RgTZ_5qvazE (дата звернення: 25.05.2024).
5.	Методичні вказівки до курсової роботи з навчальної дисципліни «Архітектура програмного забезпечення» для студентів усіх форм навчання спеціальності 121 – «Інженерія програмного забезпечення» [Електронне видання] / Упоряд. В.О. Лещинський, І.О. Лещинська, І.П. Сокорчук – Харків: ХНУРЕ, 2021. – 37 с.
 

ДОДАТОК А
Розроблені діаграми


А.1 UML діаграма розгортання системи
 
Рисунок А.1 – UML діаграма розгортання системи
 

А.2 UML діаграма прецедентів для адміністрації готельної мережі

 
Рисунок А.2 – UML діаграма прецедентів для адміністрації готельної мережі
 
А.3 UML діаграма прецедентів для клієнта готельної мережі

 
Рисунок А.3 – UML діаграма прецедентів для клієнта готельної мережі
 
А.4 ER-діаграма даних для серверної частини застосунку

 
Рисунок А.4 – ER-діаграма даних для серверної частини застосунку
 
А.5 UML діаграма пакетів для серверної частини застосунку

 
Рисунок А.5 – UML діаграма пакетів для серверної частини застосунку
 
А.6 UML діаграма прецедентів програмного забезпечення для IoT-пристрою

 
Рисунок А.6 – UML діаграма прецедентів для IoT-пристрою
 
А.7 UML діаграма взаємодії IoT-пристрою з серверною частиною системи

 
Рисунок А.7 – UML діаграма взаємодії IoT-пристрою з серверною частиною системи
А.8 UML діаграма пакетів програмного забезпечення для IoT-пристрою

 
Рисунок А.8 – UML діаграма пакетів програмного забезпечення для IoT-пристрою
 
А.9 UML діаграма діяльності для IoT-пристрою

 
Рисунок А.9 – UML діаграма діяльності для IoT-пристрою
 
А.10 UML діаграма компонент для клієнтського веб-застосунку


 
Рисунок А.10 – UML діаграма компонент для клієнтського веб-застосунку
 
А.11 UML діаграма компонент для клієнтського веб-застосунку

 
Рисунок А.11 – UML діаграма компонент для клієнтського веб-застосунку
 
А.12 UML діаграма діяльності для клієнтського веб-застосунку

 
Рисунок А.12 – UML діаграма діяльності для клієнтського веб-застосунку
 
А.13 UML діаграма компонент для мобільного застосунку


 
Рисунок А.13 – UML діаграма компонент для мобільного застосунку
 
А.14 UML діаграма пакетів для мобільного застосунку

 
Рисунок А.14 – UML діаграма пакетів для мобільного застосунку
 
А.15 ER-модель даних мобільної платформи


 
Рисунок А.15 – ER-модель даних мобільної платформи 
ДОДАТОК Б
Фрагменти коду серверної частини системи


Б.1 Код сервісу для автентифікації та авторизації

1  export class AuthService {
2      constructor(
3          private readonly companiesService: CompaniesService,
4          private readonly clientsService: ClientsService,
5          private readonly jwtService: JwtService,
6          private readonly config: ConfigService
7      ) {}
8  
9      async validateUser(profile: Profile) {
10          const email = profile.emails[0].value
11          let client = await this.clientsService.getByEmail(email)
12  
13          if (!client) {
14              const dto: CreateClientDto = {
15                  email,
16                  name: profile.displayName || profile.username,
17              }
18  
19              client = await this.clientsService.create(dto)
20          }
21  
22          return {
23              sub: client.id,
24              email: client.email,
25              role: Role.Client,
26          }
27      }
28  
29      async signupCompany(dto: CreateCompanyDto) {
30          const password = await bcrypt.hash(dto.password, 10)
31          return this.companiesService.create({ ...dto, password })
32      }
33  
34      async signinCompany(dto: SigninDto) {
35          const { email, password } = dto
36          const company = await this.companiesService.getByEmail(email)
37  
38          if (!company || !(await bcrypt.compare(password, company.password))) {
39              throw new UnauthorizedException("Invalid credentials")
40          }
41  
42          return company
43      }
44  
45      signJwt(payload: JwtPayload) {
46          return this.jwtService.sign(payload, {
47              secret: this.config.get<string>("ACCESS_TOKEN_SECRET"),
48              expiresIn: this.config.get<string>("ACCESS_TOKENT_EXPIRATION_TIME"),
49          })
50      }
51  }


Б.2 Guard для захисту ендпоінтів на основі статусу автентифікації та авторизації користувача


1  export function AccessTokenGuard(role: Role | null = null) {
2      class RoleGuardMixin implements CanActivate {
3          constructor(
4              @Inject(JwtService)
5              readonly jwtService: JwtService,
6              readonly configService: ConfigService
7          ) {}
8  
9          async canActivate(context: ExecutionContext): Promise<boolean> {
10              const request = context.switchToHttp().getRequest()
11              const token = this.extractTokenFromHeader(request)
12              let payload = {} as JwtPayload
13  
14              if (!token) {
15                  throw new UnauthorizedException()
16              }
17  
18              try {
19                  payload = await this.jwtService.verifyAsync(token, {
20                      secret: this.configService.getOrThrow<string>(
21                          "ACCESS_TOKEN_SECRET"
22                      ),
23                  })
24  
25                  request["user"] = payload
26              } catch (e) {
27                  console.error(e)
28                  throw new UnauthorizedException()
29              }
30  
31              if (role && payload.role !== role) {
32                  throw new ForbiddenException()
33              }
34  
35              return true
36          }
37  
38          extractTokenFromHeader(request: Request): string | undefined {
39              const [type, token] =
40                  request.headers.authorization?.split(" ") ?? []
41              return type === "Bearer" ? token : undefined
42          }
43      }
44  
45      const guard = mixin(RoleGuardMixin)
46      return guard
47  }
48  



Б.3 Методи для керування статусом активності кліматичного профілю


1    async getActiveProfile(roomId: string) {
2      const room = await this.getById(roomId);
3  
4      if (!room) {
5        return null;
6      }
7  
8      let profile: ClimateProfile | null = null;
9  
10      for (const client of room.clients) {
11        const activeProfile =
12          await this.climateProfilesService.getActiveProfileForClient(client.id);
13  
14        if (activeProfile) {
15          profile = activeProfile;
16          break;
17        }
18      }
19  
20      return profile;
21    }
22  
23    async setActiveProfile(setProfileActiveDto: SetProfileActiveDto) {
24      const { roomId, profileId, isActive } = setProfileActiveDto;
25  
26      const room = await this.getById(roomId);
27  
28      if (!room) {
29        throw new NotFoundException('Room with given id does not exist');
30      }
31  
32      if (isActive) {
33        for (const client of room.clients) {
34          for (const profile of client.climateProfiles) {
35            await this.climateProfilesService.update(profile.id, {
36              isActive: false,
37            });
38          }
39        }
40      }
41  
42      return this.climateProfilesService.update(profileId, { isActive });


Б.4 Код сервісу для отримання статистики


1  export class StatsService {
2    constructor(
3      @InjectRepository(ClimateDevice)
4      private readonly climateDeviceRepo: Repository<ClimateDevice>,
5      @InjectRepository(Room)
6      private readonly roomRepo: Repository<Room>,
7      @InjectRepository(Hotel)
8      private readonly hotelRepo: Repository<Hotel>,
9    ) {}
10  
11    async getClimateDeviceStats(companyId: string) {
12      const roomIds = await this.getRoomIdsByCompany(companyId);
13  
14      const total = await this.climateDeviceRepo.count({
15        where: { roomId: In(roomIds) },
16      });
17  
18      const statuses = await this.climateDeviceRepo
19        .createQueryBuilder('climateDevice')
20        .select('climateDevice.status', 'status')
21        .addSelect('COUNT(*)', 'count')
22        .where('climateDevice.roomId IN (:...roomIds)', { roomIds })
23        .groupBy('climateDevice.status')
24        .getRawMany();
25  
26      const groups = statuses.map((status) => {
27        const count = parseInt(status.count, 10);
28        return {
29          status: status.status.toLowerCase(),
30          count,
31          percentage: Math.round((count / total) * 100),
32        };
33      });
34  
35      return {
36        total,
37        groups,
38      };
39    }
40  
41    async getManufacturerStatistics(companyId: string) {
42      const roomIds = await this.getRoomIdsByCompany(companyId);
43  
44      const warningCounts = await this.countDevicesByStatusAndManufacturer(
45        ClimateDeviceStatus.Warning,
46        roomIds,
47      );
48      const errorCounts = await this.countDevicesByStatusAndManufacturer(
49        ClimateDeviceStatus.Error,
50        roomIds,
51      );
52  
53      const warningMap = new Map<string, number>();
54      const errorMap = new Map<string, number>();
55  
56      warningCounts.forEach(({ manufacturer, count }) => {
57        warningMap.set(manufacturer, parseInt(count, 10));
58      });
59  
60      errorCounts.forEach(({ manufacturer, count }) => {
61        errorMap.set(manufacturer, parseInt(count, 10));
62      });
63  
64      const manufacturers = new Set([...warningMap.keys(), ...errorMap.keys()]);
65  
66      const results = Array.from(manufacturers).map((manufacturer) => ({
67        manufacturer,
68        warningCount: warningMap.get(manufacturer) || 0,
69        errorCount: errorMap.get(manufacturer) || 0,
70      }));
71  
72      results.sort((a, b) => {
73        if (b.errorCount !== a.errorCount) {
74          return b.errorCount - a.errorCount;
75        }
76  
77        return b.warningCount - a.warningCount;
78      });
79  
80      return results;
81    }
82  
83    async getClimateDeviceStatisticsForHotel(hotelId: string) {
84      const rooms = await this.roomRepo.find({ where: { hotelId } });
85      const roomIds = rooms.map((room) => room.id);
86  
87      const total = await this.climateDeviceRepo.count({
88        where: { roomId: In(roomIds) },
89      });
90  
91      const statuses = await this.climateDeviceRepo
92        .createQueryBuilder('climateDevice')
93        .select('climateDevice.status', 'status')
94        .addSelect('COUNT(*)', 'count')
95        .where('climateDevice.roomId IN (:...roomIds)', { roomIds })
96        .groupBy('climateDevice.status')
97        .getRawMany();
98  
99      const groups = statuses.map((status) => {
100        const count = parseInt(status.count, 10);
101        return {
102          status: status.status.toLowerCase(),
103          count,
104          percentage: Math.round((count / total) * 100),
105        };
106      });
107  
108      return {
109        total,
110        groups,
111      };
112    }
113  
114    private async getHotelIdsByCompany(companyId: string) {
115      const hotels = await this.hotelRepo.findBy({ companyId });
116      return hotels.map((hotel) => hotel.id);
117    }
118  
119    private async getRoomIdsByCompany(companyId: string) {
120      const hotelsIds = await this.getHotelIdsByCompany(companyId);
121  
122      const rooms = await this.roomRepo.findBy({ hotelId: In(hotelsIds) });
123      const roomIds = rooms.map((room) => room.id);
124  
125      return roomIds;
126    }
127  
128    private async countDevicesByStatusAndManufacturer(
129      status: ClimateDeviceStatus,
130      roomIds: string[],
131    ) {
132      return this.climateDeviceRepo
133        .createQueryBuilder('climateDevice')
134        .select('climateDevice.manufacturer', 'manufacturer')
135        .where('climateDevice.roomId IN (:...roomIds)', { roomIds })
136        .addSelect('COUNT(*)', 'count')
137        .where('climateDevice.status = :status', {
138          status,
139        })
140        .groupBy('climateDevice.manufacturer')
141        .getRawMany();
142    }
 
ДОДАТОК В
Фрагменти коду ПЗ для вбудованих систем


В.1 Приклад методу для конфігурації пристрою

1  def get_polling_interval():
2      while True:
3          try:
4              user_input = input("Enter polling interval in seconds (minimum 15, default 60): ")
5  
6              if user_input == '':
7                  config.POLLING_INTERVAL = 60
8                  retur
9  
10              interval = int(user_input)
11              if interval >= 15:
12                  config.POLLING_INTERVAL = interval
13                  retur
14              else:
15                  print("Polling interval must be at least 15 seconds.")
16          except ValueError:


В.2 Код класу для конвертації одиниць вимірювання


1  class UnitsConverter:
2      def __init__(self):
3          pass
4  
5      def humidity_percentage_to_fraction(self, humidity_percent):
6          if 0 <= humidity_percent <= 100:
7              return humidity_percent / 100
8          else:
9              raise ValueError("Humidity percentage must be between 0 and 100")
10  
11      def humidity_fraction_to_percentage(self, fraction):
12          return fraction * 100
13  
14      def celsius_to_fahrenheit(self, celsius):
15          return (celsius * 9/5) + 32
16  
17      def celsius_to_kelvin(self, celsius):
18          return celsius + 273
19  
20      def fahrenheit_to_celsius(self, fahrenheit):
21          return (fahrenheit - 32) * 5/9
22  
23      def fahrenheit_to_kelvin(self, fahrenheit):
24          return self.celsius_to_kelvin(self.fahrenheit_to_celsius(fahrenheit))
25  
26      def kelvin_to_celsius(self, kelvin):
27          return kelvin - 273
28  
29      def kelvin_to_fahrenheit(self, kelvin):
30          return self.celsius_to_fahrenheit(self.kelvin_to_celsius(kelvin))
31  
32      def convert_temperature(self, value, from_unit, to_unit):
33          if from_unit == to_unit:
34              return value
35  
36          if from_unit == 'C':
37              if to_unit == 'F':
38                  return self.celsius_to_fahrenheit(value)
39              elif to_unit == 'K':
40                  return self.celsius_to_kelvin(value)
41          elif from_unit == 'F':
42              if to_unit == 'C':
43                  return self.fahrenheit_to_celsius(value)
44              elif to_unit == 'K':
45                  return self.fahrenheit_to_kelvin(value)
46          elif from_unit == 'K':
47              if to_unit == 'C':
48                  return self.kelvin_to_celsius(value)
49              elif to_unit == 'F':
50                  return self.kelvin_to_fahrenheit(value)
51          else:
52              raise ValueError("Invalid temperature unit. Use 'C', 'F', or 'K'.")
53      
54      def convert_humidity(self, value, from_unit, to_unit):
55          if from_unit == to_unit:
56              return value
57          
58          if from_unit == "%":
59              if to_unit == "1":
60                  return self.humidity_percentage_to_fraction(value)
61          elif from_unit == "1":
62              if to_unit == "%":
63                  return self.humidity_fraction_to_percentage(value)
64          else:





В.3 Методи для здійснення запиту на зміну кліматичних налаштувань до пристрою для управління кліматом


1  def get_apply_payload_value(self, device, profile):
2      if (device.type == ClimateDeviceType.THERMOSTAT):
3          return profile.temperature
4      else:
5          return profile.humidity
6  
7  def convert_payload_units(self, value, current_units, desired_untis, device):
8      if (device.type == ClimateDeviceType.THERMOSTAT):
9          return self.units_converter.convert_temperature(value, current_units, desired_untis)
10      else:
11          return self.units_converter.convert_humidity(value, current_units, desired_untis)
12  
13  def get_apply_profile_payload(self, device, profile):
14      desired_untis = self.get_desired_units(device)
15      server_units = self.get_server_units(device)
16  
17      payload_value = self.get_apply_payload_value(device, profile)
18  
19      payload_value = self.convert_payload_units(payload_value, server_units, desired_untis, device)
20  
21      payload = {
22          'value': payload_value,
23          'units': desired_untis
24      }
25  
26      return payload
27  
28  def apply_profile(self, device, profile):
29      payload = self.get_apply_profile_payload(device, profile)
30  
31      self.logger.info('Applying new profile for device {} with payload {}'.format(device.id, payload))
32  
33      response = dict()
34      
35      if (device.id == "a4e606bd-d31d-456f-812b-0b3109844d5d"):
36          response = {
37              'status': ClimateDeviceStatus.WARNING,
38              'message': 'warning message'
39          }
40      else:
41          response = {
42              'status': ClimateDeviceStatus.OK,
43              'message': ''
44          }
В.4 Метод для відправки листа з попередженням про незадовільний стан кліматичного пристрою


1  def send_warning_email(response, device):
2      logger.info("Sending {} message for device {}".format(response["status"], device.id))
3  
4      smtp_crentials = get_smtp_credentials(config.SERVER_URL)
5      room_number = room_service.get_number_by_id(config.ROOM_ID)
6  
7      email_sender = "From: {} <{}>n".format(config.EMAIL_SENDER_NAME, smtp_crentials["email"])
8      email_subject = "Subject: Actions needed for cliamte device with accession number {} in room {}n".format(device.accessionNumber, room_number)
9  
10      email_status_string = ""
11  
12      if (response["status"] == ClimateDeviceStatus.WARNING):
13          email_status_string = "reported a warning"
14      else:
15          email_status_string = "reported an error"
16  
17      email_recommendations = ""
18  
19      if (response["status"] == ClimateDeviceStatus.WARNING):
20          email_recommendations = "Make sure to take neccessary actions"
21      else:
22          email_recommendations = "Immediate actions are necessary"
23  
24      email_body = """
25  Greetings!
26  
27  A climate device with accession number {} in room {} {} with following message: {}
28  
29  {}
30  """.format(device.accessionNumber, room_number, email_status_string, response["message"], email_recommendations)
31  
32      smtp = umail.SMTP('smtp.gmail.com', 587, username=smtp_crentials["email"], password=smtp_crentials["password"])
33      smtp.to(config.COMPANY_EMAIL)
34      smtp.write(email_sender)
35      smtp.write(email_subject)
 
ДОДАТОК Г
Фрагменти коду клієнтського веб-застосунку


Г.1 Компонент вищого порядку для захисту сторінок застосунку на основі статусу автентифікації

1  function ProtectedRouteComponent({ children }: { children: JSX.Element }) {
2      useEffect(() => {
3          if (!authStore.isReady) {
4              const accessToken = localStorage.getItem(ACCESS_TOKEN_LS_KEY)
5  
6              if (!accessToken) {
7                  authStore.setReady(true)
8                  retur
9              }
10  
11              const tokenPayload = jwtDecode<JwtPayload>(accessToken)
12  
13              if (tokenPayload.role === Role.Company) {
14                  authStore.getCompanyProfile()
15              }
16          }
17      })
18  
19      if (!authStore.isReady) {
20          return <Spin spinning size="large" />
21      }
22  
23      if (!authStore.company) {
24          console.log(!authStore.client)
25          console.log(!authStore.company)
26          return <Navigate to="/auth/company/signin" replace />
27      }
28  
29      return children
30  }
31  
32  const ProtectedRoute = observer(ProtectedRouteComponent)
33  export default ProtectedRoute




Г.2 Приклад сторінки для управління сутністю системи


1  function ClimateDevicesComponent() {
2      const { t } = useTranslation()
3      const [isCreateModalVisible, setCreateModalVisible] =
4          useState<boolean>(false)
5      const { isLoading, isReady } = climateDeviceStore
6      const { roomId } = useParams<RouteParams>()
7  
8      useEffect(() => {
9          climateDeviceStore.setRoomId(roomId!)
10  
11          if (!isReady) {
12              climateDeviceStore.fetchAll()
13          }
14      }, [isReady, roomId])
15  
16      if (isLoading) {
17          return <Spin spinning fullscreen size="large" />
18      }
19  
20      return (
21          <div className={styles["rooms-page"]}>
22              <CreateClimateDeviceModal
23                  open={isCreateModalVisible}
24                  setOpen={(value) => setCreateModalVisible(value)}
25              />
26              <div className={styles["title-wrapper"]}>
27                  <PageTitle title={t("climateDevices")} />
28                  <Butto
29                      shape="circle"
30                      onClick={() => setCreateModalVisible(true)}
31                  >
32                      <PlusOutlined />
33                  </Button>
34              </div>
35              <ClimateDeviceList />
36          </div>
37      )
38  }
39  
40  const ClimateDevices = observer(ClimateDevicesComponent)
41  export default ClimateDevices





Г.3 Приклад класу-сховища з логікою для обробки даних щодо певної сутності


1  class ClientStore {
2      constructor() {
3          makeAutoObservable(this)
4      }
5  
6      clients: Client[] = []
7      isLoading: boolean = false
8      isReady: boolean = false
9      needsUpdate: boolean = false
10  
11      async fetchAll() {
12          try {
13              runInAction(() => {
14                  this.isLoading = true
15              })
16  
17              const clients = await clientApi.getAll()
18  
19              runInAction(() => {
20                  this.clients = clients
21                  this.isReady = true
22              })
23          } catch (error) {
24              message.error(t("fetchClientsError"))
25          } finally {
26              runInAction(() => {
27                  this.isLoading = false
28              })
29          }
30      }
31  
32      async create(dto: CreateClientDto) {
33          try {
34              runInAction(() => {
35                  this.isLoading = true
36              })
37  
38              await clientApi.create(dto)
39  
40              runInAction(() => {
41                  this.needsUpdate = true
42              })
43          } catch (error) {
44              message.error(t("createClientError"))
45          } finally {
46              runInAction(() => {
47                  this.isLoading = false
48              })
49          }
50      }
51  
52      async update(id: string, dto: UpdateClientDto) {
53          try {
54              runInAction(() => {
55                  this.isLoading = true
56              })
57  
58              await clientApi.update(id, dto)
59  
60              runInAction(() => {
61                  this.needsUpdate = true
62              })
63          } catch (error) {
64              message.error(t("updateClientError"))
65          } finally {
66              runInAction(() => {
67                  this.isLoading = false
68              })
69          }
70      }
71  
72      async delete(id: string) {
73          try {
74              runInAction(() => {
75                  this.isLoading = true
76              })
77  
78              await clientApi.delete(id)
79  
80              runInAction(() => {
81                  this.needsUpdate = true
82              })
83          } catch (error) {
84              message.error(t("deleteClientError"))
85          } finally {
86              runInAction(() => {
87                  this.isLoading = false
88              })
89          }
90      }
91  }
92  
93  export const clientStore = new ClientStore()
94  
95  autorun(async () => {
96      if (clientStore.needsUpdate) {
97          await clientStore.fetchAll()
98  
99          runInAction(() => {
100              clientStore.needsUpdate = false
101          })
102      }
103  })



Г.4 Приклад класу-api для отримання даних з серверної частини системи


1  class ClientApi {
2      private axiosInstance = getAxiosInstance({
3          baseURL: `${import.meta.env.VITE_API_BASE_URL}/clients`,
4      })
5  
6      async getAll(): Promise<Client[]> {
7          const response = await this.axiosInstance.get("")
8          return response.data
9      }
10  
11      async getById(id: string): Promise<Client> {
12          const response = await this.axiosInstance.get(`${id}`)
13          return response.data
14      }
15  
16      async create(dto: CreateClientDto): Promise<Client> {
17          const response = await this.axiosInstance.post("", dto)
18          return response.data
19      }
20  
21      async update(id: string, dto: UpdateClientDto): Promise<Client> {
22          const response = await this.axiosInstance.patch(`${id}`, dto)
23          return response.data
24      }
25  
26      async delete(id: string): Promise<Client> {
27          const response = await this.axiosInstance.delete(`${id}`)
28          return response.data
29      }
30  }
31  

 
ДОДАТОК Д
Фрагменти коду мобільного застосунку


Д.1 ViewModel для збереження стану авторизації користувача


     1	class AuthStateViewModel : ViewModel() {
     2	    private val _authState = MutableStateFlow(AuthState(isAuthenticated = false))
     3	    val authState: StateFlow<AuthState> = _authState
     4	    var didLogout by mutableStateOf(false)
     5	
     6	    fun setAuthState(isAuthenticated: Boolean, accessToken: String?, client: Client?) {
     7	        _authState.value = AuthState(isAuthenticated, accessToken, client)
     8	    }
     9	
    10	    fun clearAuthState() {
    11	        _authState.value = AuthState(isAuthenticated = false)
    12	    }
    13	}


Д.2 Клас-API для отримання інформації про кліматичні профілі


     1	class ClimateProfileApi(private val httpClient: HttpClient) : IClimateProfileApi {
     2	    override suspend fun getAll(token: String): List<ClimateProfile> {
     3	        val response = httpClient.get {
     4	            url(HttpRoutes.CLIMATE_PROFILES)
     5	            headers {
     6	                append("Authorization", "Bearer $token")
     7	            }
     8	        }
     9	
    10	        return response.body()
    11	    }
    12	
    13	    override suspend fun getById(id: String, token: String): ClimateProfile {
    14	        val response = httpClient.get {
    15	            url("${HttpRoutes.CLIMATE_PROFILES}/$id")
    16	            headers {
    17	                append("Authorization", "Bearer $token")
    18	            }
    19	        }
    20	
    21	        return response.body()
    22	    }
    23	
    24	    override suspend fun create(dto: CreateClimateProfileDto, token: String): ClimateProfile {
    25	        val response = httpClient.post {
    26	            url(HttpRoutes.CLIMATE_PROFILES)
    27	            headers {
    28	                append("Authorization", "Bearer $token")
    29	            }
    30	            setBody(dto)
    31	        }
    32	
    33	        return response.body()
    34	    }
    35	
    36	    override suspend fun update(
    37	        id: String,
    38	        dto: UpdateClimateProfileDto,
    39	        token: String
    40	    ): ClimateProfile {
    41	        val response = httpClient.patch {
    42	            url("${HttpRoutes.CLIMATE_PROFILES}/$id")
    43	            headers {
    44	                append("Authorization", "Bearer $token")
    45	            }
    46	            setBody(dto)
    47	        }
    48	
    49	        return response.body()
    50	    }
    51	
    52	    override suspend fun delete(id: String, token: String) {
    53	        httpClient.delete {
    54	            url("${HttpRoutes.CLIMATE_PROFILES}/$id")
    55	            headers {
    56	                append("Authorization", "Bearer $token")
    57	            }
    58	        }
    59	    }
    60	}





Д.3 Вспливаюче вікно для створення нового кліматичного профілю


     1	@Composable
     2	fun CreateClimateProfileDialog(
     3	    onDismiss: () -> Unit,
     4	    onCreate: (CreateClimateProfileDto) -> Unit,
     5	) {
     6	    var name by remember { mutableStateOf("") }
     7	    var temperature by remember { mutableStateOf("") }
     8	    var humidity by remember { mutableStateOf("") }
     9	
    10	    AlertDialog(
    11	        onDismissRequest = onDismiss,
    12	        title = { Text(text = stringResource(R.string.create_climate_profile)) },
    13	
    14	        text = {
    15	            Column {
    16	                OutlinedTextField(
    17	                    value = name,
    18	                    onValueChange = { name = it },
    19	                    label = { Text(stringResource(R.string.name)) })
    20	                Spacer(modifier = Modifier.height(12.dp))
    21	                OutlinedTextField(
    22	                    value = temperature,
    23	                    onValueChange = { temperature = it },
    24	                    label = { Text("${stringResource(R.string.temperature)} (°C)") },
    25	                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)
    26	                )
    27	                Spacer(modifier = Modifier.height(12.dp))
    28	                OutlinedTextField(
    29	                    value = humidity,
    30	                    onValueChange = { humidity = it },
    31	                    label = { Text("${stringResource(R.string.humidity)} (%)") },
    32	                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)
    33	                )
    34	            }
    35	        },
    36	
    37	        confirmButton = {
    38	            TextButton(onClick = {
    39	                val newProfile = CreateClimateProfileDto(
    40	                    name = name,
    41	                    temperature = temperature.toIntOrNull() ?: 0,
    42	                    humidity = humidity.toIntOrNull() ?: 0,
    43	                )
    44	                onCreate(newProfile)
    45	            }) {
    46	                Text(stringResource(R.string.create))
    47	            }
    48	        },
    49	
    50	        dismissButton = {
    51	            TextButton(onClick = onDismiss) {
    52	                Text(stringResource(R.string.cancel))
    53	            }
    54	        }
    55	    )
    56	}

